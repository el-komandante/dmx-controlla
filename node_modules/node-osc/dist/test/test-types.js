'use strict';

var util = require('./util.js');
var types = require('node-osc/types');

util.test('Type: string', async (t) => {
  const str = new types.TString('come on fhqwhgads');
  t.equals(str.typetag, 's');
  t.equals(str.value, 'come on fhqwhgads');
  t.done();
});

util.test('Type: string decode', async (t) => {
  const str = new types.TString();
  str.decode(Buffer.from('test\0/123\0'));
  t.equals(str.value, 'test');
  t.done();
});

util.test('Type: string bad message', async (t) => {
  t.throws(() => {
    const str = new types.TString();
    str.decode(Buffer.from('test'));
  }, 'OSC string not null terminated');
  t.done();
});

util.test('Type: int', async (t) => {
  const int = new types.TInt(13);
  t.equals(int.typetag, 'i');
  t.equals(int.value, 13);
  t.done();
});

util.test('Type: bad int decode', async (t) => {
  const int = new types.TInt('0');
  t.throws(() => {
    int.decode('01');
  }, 'buffer [48, 49] too short for int, 4 bytes requiredLength');
  t.done();
});

util.test('Type: float', async (t) => {
  const float = new types.TFloat(3.14);
  t.equals(float.typetag, 'f');
  t.equals(float.value, 3.14);
  t.done();
});

util.test('Type: bad float decode', async (t) => {
  const float = new types.TFloat(3.14);
  t.throws(() => {
    float.decode('01');
  }, 'buffer [48, 49] too short for int, 4 bytes requiredLength');
  t.done();
});

util.test('Type: double', async (t) => {
  const double = new types.TDouble(1337);
  t.equals(double.typetag, 'd');
  t.equals(double.value, 1337);
  t.done();
});

util.test('Type: bad double decode', async (t) => {
  const double = new types.TDouble(1337);
  t.throws(() => {
    double.decode('01');
  }, 'buffer [48, 49] too short for int, 4 bytes requiredLength');
  t.done();
});

util.test('Type: false', async (t) => {
  const f = new types.TFalse(false);
  t.equals(f.value, false);
  t.equals(f.decode(0, 0), 0, 'decode is passthourgh');
  t.done();
});

util.test('Type: true', async (t) => {
  const tt = new types.TTrue(true);
  t.equals(tt.value, true);
  t.equals(tt.decode(0, 0), 0, 'decode is passthourgh');
  t.done();
});

util.test('Type: time', async (t) => {
  const date = new Date();
  const time = new types.TTime(date);
  t.equals(time.typetag, 't');
  t.equals(time.value, date);
  t.done();
});

util.test('Type: time decode', async (t) => {
  const time = new types.TTime();
  time.decode(Buffer.from('12345.12345\0'));
  t.equals(time.typetag, 't');
  t.equals(time.value, 825373492.2077361);
  t.done();
});

util.test('Type: time bad buffer', async (t) => {
  const time = new types.TTime();
  t.throws(() => {
    time.decode(Buffer.from(''));
  }, /buffer \[\] too short for time, 8 bytes requiredLength/);
  t.done();
});
